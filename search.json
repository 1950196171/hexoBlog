[{"title":"接口开发","url":"/2019/01/07/接口开发/","content":"# 前、后端分离\n\n随着前端设备（智能手机、IPAD、平板、笔记本、摄像头、智能家具等）的及物联网的发展，前端的形式变得更加多样化：\n\n![](http://d.hiphotos.baidu.com/image/%70%69%63/item/cefc1e178a82b90189e5c5b87e8da9773812eff5.jpg)\n\n在这种时代的大背景下，传统的 `在前端代码中嵌入后端代码的混合式开发` 已经无法满足目前的情况了。\n\n前端技术慢慢从后端开发中分离了出来，前端只关注前端页在，后端只负责数据的处理，后端负责提供数据接口与前端进行通信，通信时一般使用 `json/xml` 格式。\n\n\n\n既然前、后端通过接口进行沟通，那么我们就要为接口定义一个规范，如果所有的接口都满足同样的规范，就可以降低沟通和开发的成本。\n\n\n\n# REST 规范\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/bf096b63f6246b6004beb4ffe6f81a4c500fa28c.jpg)\nRESTful 是一种软件设计风格，由 [Roy Fielding](http://roy.gbiv.com/) 在他的 [论文](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) 中提出，全称为 `Representational State Transfer`，直译为`表现层状态转移`。\n\nRESTful 风格的接口，目前来看，实现的最好的就是 [Github API](https://developer.github.com/v3/)，经常被效仿。接下来我们通过分析 Github API 来引出我们的 API 设计原则。\n\n\n\n## 使用 HTTPS\n\nHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。\n\nHTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n\nHTTPS 为接口的安全提供了保障，可以有效防止通信被窃听和篡改。\n\n\n\n## 域名\n\n应当尽可能的将 API 与其主域名区分开，可以使用专用的域名，访问我们的 API，例如：\n\n```php\nhttps://api.xxx.com\n```\n\n或者可以放在主域名下，例如：\n\n~~~\nhttps://www.xxx.com/api\n~~~\n\n\n\n## 版本控制\n\n随着业务的发展，需求的不断变化，API 的迭代是必然的，很可能当前版本正在使用，而我们就得开发甚至上线一个不兼容的新版本，为了让旧用户可以正常使用，为了保证开发的顺利进行，我们需要控制好 API 的版本。\n\n通常情况下，有两种做法：\n\n- 将版本号直接加入 URL 中\n\n~~~\nhttps://api.xxx.com/v1\nhttps://api.xxx.com/v2\n~~~\n\n\n\n\n\n## 接口命名\n\n规则一、使用 HTTP 动词代表操作的类型。\n\n| 动词   | 描述                               |\n| ------ | ---------------------------------- |\n| GET    | 获取资源，单个或多个               |\n| POST   | 创建资源                           |\n| PUT    | 更新资源，客户端提供完整的资源数据 |\n| PATCH  | 更新资源，客户端提供部分的资源数据 |\n| DELETE | 删除资源                           |\n\nGitHub 网站的一些例子：\n\n~~~\nGET /issues                                      列出所有的 issue\nGET /repos/:owner/:repo                          列出某个项目的 信息\nGET /repos/:owner/:repo/issues/:number           获取某个项目的某个 issue\nPOST /repos/:owner/:repo/issues                  为某个项目创建 issue\nPATCH /repos/:owner/:repo/issues/:number         修改某个 issue\nPUT /repos/:owner/:repo/issues/:number/lock      锁住某个 issue\nDELETE /repos/:owner/:repo/issues/:number/lock   接收某个 issue\n~~~\n\n说明：冒号（：xx)）开始的代表变量，例如 /repos/fortheday001/jxshop\n\n\n\n规则二、接口地址的命名应该是名词（一般是复数形式）\n\n错误的例子：\n\n~~~\nPOST https://api.xxx.com/createTopic\nGET https://api.xxx.com/topic/show/1\nPOST https://api.xxx.com/topics/1/comments/create\nPOST https://api.xxx.com/topics/1/comments/100/delete\n~~~\n\n\n\n正确的例子（名词）：\n\n~~~\nPOST https://api.xxx.com/topics\nGET https://api.xxx.com/topics/1\nPOST https://api.xxx.com/topics/1/comments\nDELETE https://api.xxx.com/topics/1/comments/100\n~~~\n\n\n\n\n\n## 资源过滤\n\n当我们需要搜索、排序、分页等过滤数据时我们需要在 URL 传合适的参数：\n\n~~~\n?state=closed: 不同状态的资源\n?page=2&per_page=100：访问第几页数据，每页多少条。\n?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n~~~\n\n\n\n比如获取10条用户的请求地址为：\n\n~~~\nGET /users?per_page=10\n~~~\n\n\n\n\n\n## 正确使用状态码\n\n接口在返回数据时应该正确的返回 HTTP 对应的状态码，常用的状态码如下：\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/a8773912b31bb05132a9b5a33b7adab44bede0a8.jpg)\n\n![](http://b.hiphotos.baidu.com/image/%70%69%63/item/2fdda3cc7cd98d1038f10dba2c3fb80e7bec9017.jpg)\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/d000baa1cd11728bc2498da9c5fcc3cec2fd2cd0.jpg)\n\n\n\n常用状态码：\n\n~~~php\n$_http_code = [\n    200 => \"OK\",                   // 成功\n    400 => \"Bad Request\",          // 请求数据有问题\n    401 => \"Unauthorized\",         // 未登录\n    403 => \"Forbidden\",            // 登录但没有权限\n    404 => \"Not Found\",            // 请求数据没找到\n];\n~~~\n\n\n\n\n\n## 数据响应格式\n\n接口应该返回 `JSON` 或者 `XML` 格式的数据。\n\n返回的数据的结构应该有一个固定的结构，这个结构可以自己设计，比如：\n\n~~~\n'message' => ':message',          // 错误的具体描述\n'errors' => ':errors',            // 参数的具体错误描述，422 等状态提供\n'code' => ':code',                // 自定义的异常码\n'status_code' => ':status_code',  // http状态码\n'debug' => ':debug',              // debug 信息，非生产环境提供\n~~~\n\n例如：\n\n~~~json\n{\n    \"message\": \"422 Unprocessable Entity\",\n    \"errors\": {\n        \"name\": [\n            \"姓名 必须为字符串。\"\n        ]\n    },\n    \"status_code\": 422\n}\n~~~\n\n~~~json\n{\n    \"message\": \"您无权访问该订单\",\n    \"status_code\": 403\n}\n~~~\n\n\n\n## 频繁限制\n\n为了防止服务器被攻击，减少服务器压力，需要对接口进行合适的限流控制，需要在响应头信息中加入合适的信息，告知客户端当前的限流情况\n\n- X-RateLimit-Limit :100 最大访问次数\n- X-RateLimit-Remaining :93 剩余的访问次数\n- X-RateLimit-Reset :1513784506 到该时间点，访问次数会重置为 `X-RateLimit-Limit`\n\n示例：\n\n~~~\ncurl -i https://api.github.com/users/octocat\nHTTP/1.1 200 OK\nDate: Mon, 01 Jul 2013 17:27:06 GMT\nStatus: 200 OK\nX-RateLimit-Limit: 60\nX-RateLimit-Remaining: 56\nX-RateLimit-Reset: 1372700873\n~~~\n\n\n\n超过限流次数后，需要返回 `429 Too Many Requests` 错误。\n\n\n\n\n\n## 编写文档\n\n为了方便用户使用，我们需要提供清晰的文档，尽可能包括以下几点\n\n- 包括每个接口的请求参数，每个参数的类型限制，是否必填，可选的值等。\n- 响应结果的例子说明，包括响应结果中，每个参数的释义。\n- 对于某一类接口，需要有尽量详细的文字说明，比如针对一些特定场景，接口应该如何调用。\n\n\n\n# Postman\n\npostman 是一个接口访问软件，非常适合服务器端程序员用来测试接口、发布接口文档等。\n\n[img]http://g.hiphotos.baidu.com/image/%70%69%63/item/5366d0160924ab180910e0bc38fae6cd7b890b32.jpg[/img]\n\n\n\n## 集合管理\n\n我们可以在左侧创建接口集合，将项目中所有的接口都统一分类管理起来：\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/d058ccbf6c81800a73e78885bc3533fa828b473e.jpg)\n\n\n\n## 环境变量\n\n我们可以在软件中管理环境变量，环境变量可以让我们把系统的IP地址、JWT字符串等常用的内容定义到变量中保存，然后通过变量来使用这个数据，就不用每次都填写了：\n\n![](http://e.hiphotos.baidu.com/image/%70%69%63/item/1e30e924b899a90190a85abd10950a7b0308f598.jpg)\n\n添加环境变量：\n\n![](http://g.hiphotos.baidu.com/image/%70%69%63/item/3bf33a87e950352ad82924835e43fbf2b3118bf4.jpg)\n\n添加之后，就可以通过 `{{变量名}}` 来使用了：\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/d8f9d72a6059252dc4521c8f399b033b5ab5b9f7.jpg)\n\n\n\n\n\n## 保存示例数据\n\n当我们使用 postman 请求接口之后，会为我们美化服务器返回的数据：\n\n![](http://b.hiphotos.baidu.com/image/%70%69%63/item/241f95cad1c8a786b0a84b856a09c93d71cf50be.jpg)\n\n返回数据之后，我们可以点击 `Save Response` 按钮保存返回的数据，保存的目的是在制作接口文档时，这些数据可以做为示例数据，保存时可以设置一个名字：\n\n![](http://e.hiphotos.baidu.com/image/%70%69%63/item/b58f8c5494eef01f6e57194eedfe9925bd317dfd.jpg)\n\n\n\n## 生成接口文档\n\npostman 还有一个好用的功能就是可以帮助我们生成 `接口文档`。\n\n当我们编写好接口以及保存好接口返回的数据示例之后，我们就可以使用它来生成 接口文档：\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/d4628535e5dde711d83f427daaefce1b9c16614f.jpg)\n\n点击 `Publish Docs` 生成接口文档时，先选择我们要使用的环境变量：\n\n![](http://h.hiphotos.baidu.com/image/%70%69%63/item/a8014c086e061d95d5cb36b376f40ad163d9caa8.jpg)\n\n\n\n选择完之后就可以发布了，发布之后，我们就得到发布之后的浏览地址：\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/962bd40735fae6cdd95daaea02b30f2443a70f4b.jpg)\n\n把这个接口地址发给前端程序员就可以了：\n\n![](http://e.hiphotos.baidu.com/image/%70%69%63/item/8644ebf81a4c510fd54fe3916d59252dd52aa5b5.jpg)\n\n\n\n接口文档地址：https://documenter.getpostman.com/view/3908128/RzZDjxgP\n\n\n\n\n\n\n\n# Laravel\n\n\n\n## 定义路由\n\n在做接口开发时，所有的接口都定义在 `routes/api.php` 文件中。\n\n定义在 `routes/api.php` 文件中的路由有几下几个特点：\n\n1、接口地址中必须加上 api 前缀，比如：http://127.0.0.1:8000/api/goods\n\n2、没有 `csrf` 、`session`、`cookie `等传统网站开发中的常用功能（这些功能使用 jwt(json web token)（令牌）替代）\n\n3、所有接口都会有频率限制（每分钟60次）（通过 Laravel 中自带的 `throttle` 中间件实现）\n\n\n\n## 频率限制\n\n`routes/api.php` 文件中定义的路由都会默认被应用 `throttle` 中间件，`同一个IP1分钟内最多访问一个接口60次。`\n\n![](http://h.hiphotos.baidu.com/image/%70%69%63/item/908fa0ec08fa513dc9946c55306d55fbb2fbd97b.jpg)\n\n如果要为不同的接口设置不同的频率，可以在 `routes/api.php` 文件中定义路由时，先定义路由组，然后为这个路由组设置频率，所有这个组中的路由都会被应用同样的频率限制：\n\n~~~php\n// 1分钟最多5次\nRoute::group(['prefix'=>'api','middleware'=>'throttle:5'],function(){\n    Route::get('users',function(){\n        return \\App\\User::all();\n    });\n});\n// 10分钟最多5次\nRoute::group(['prefix'=>'api','middleware'=>'throttle:5,10'],function(){\n    Route::get('users',function(){\n        return \\App\\User::all();\n    });\n});\n~~~\n\n\n\n## AJAX跨域\n\n在前、后端分离开发时，前端都是使用 `ajax` 与服务器端进行通信的，但是 ajax 有一个限制：`不能跨域名访问服务器接口`。\n\n在实现工作中，前端和后端经常是部署在不同的服务器上，也就都拥有不同的域名，这时前端发送 AJAX 就会报错，比如：前端在 127.0.0.1:8000 这个域名下，而后端在 127.0.0.1:8080 这个端口下时：\n\n![](http://h.hiphotos.baidu.com/image/%70%69%63/item/bd3eb13533fa828bc9fb9c68f01f4134960a5a64.jpg)\n\n\n\n解决办法：\n\n目前常用的解决办法有 `jsonp` 和 `cors`。\n\nJSONP：只支持 GET 请求的跨域。\n\nCORS：(跨站资源共享)，实现原理是在服务器端设置几个 http 协议头即可，缺点是有些老旧的浏览器不支持。\n\n\n\nLaravel 中使用 CORS：\n\n如果每次发请求时都手动设置协议头太麻烦了，所以可以使用 Laravel 中间件来实现。\n\nLaravel 的中间件会在接收和发送请求时自动被调用，这样就可以只编写一次代码就可以在每次请求时自动设置协议头了。\n\n1、创建中间件\n\n~~~\nphp artisan make:middleware CorsMiddleware\n~~~\n\n\n\n2、编写代码\n\napp\\Http\\Middleware\\CorsMiddleware.php\n\n~~~php\npublic function handle($request, Closure $next)\n{\n    $response = $next($request);\n    $origin = $request->server('HTTP_ORIGIN') ? $request->server('HTTP_ORIGIN') : '';\n    // 允许访问的域名列表\n    $allow_origin = [\n        'http://localhost:8080',\n    ];\n    // 通过 $response->header 设置协议头\n    // (扩展：如果想要允许所有域名跨域访问，就可以去掉if判断，然后\n    // \t    直接设置 Access-Control-Allow-Origin : *)\n    if (in_array($origin, $allow_origin)) {\n        // 如果要允许所有域名跨域访问，设置把这一项设置为 *\n        $response->header('Access-Control-Allow-Origin', $origin);\n        $response->header('Access-Control-Allow-Methods', 'GET, POST, PATCH, PUT, DELETE, OPTIONS');\n        $response->header('Access-Control-Allow-Headers', 'Origin, Content-Type, Cookie, X-CSRF-TOKEN, Accept, Authorization, X-XSRF-TOKEN');\n        $response->header('Access-Control-Expose-Headers', 'Authorization, authenticated');\n        $response->header('Access-Control-Allow-Credentials', 'true');\n    }\n    return $response;\n}\n~~~\n\n\n\n3、注册中间件\n\napp\\Http\\Kernel.php 文件中注册全局中间件。\n\n注册到 `$middleware` 数组中的中间件会在所有请求时会自动调用。\n\n~~~php\nprotected $middleware = [\n    \\App\\Http\\Middleware\\CheckForMaintenanceMode::class,\n    \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class,\n    \\App\\Http\\Middleware\\TrimStrings::class,\n    \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class,\n    \\App\\Http\\Middleware\\TrustProxies::class,\n    \\App\\Http\\Middleware\\CorsMiddleware::class\n];\n~~~\n\n\n\n\n\n## 发送 HTTP 状态码\n\n在 Laravel 框架中可以直接使用 `response` 方法向前端发送数据和状态码信息。\n\n~~~php\nreturn response('无权访问！'， 403);\n~~~\n\n这时框架会在发送数据时设置一个 403 的协议头信息，当浏览器收到非 `2xx` 开头的状态码时会显示显示错误信息：\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/730e0cf3d7ca7bcb0a78c7a4b3096b63f624a83d.jpg)\n\n\n\n当我们使用 axios 请求这个地址时，如果服务器返回的是`非 2xx` 开头的状态码，那么就会认为发生了错误，错误信息需要在 `catch` 中获取：\n\n~~~js\naxios.get('http://127.0.0.1:8000/api/test')\n    .then((res)=>{\n    \t// 服务器返回了 2xx 状态码(代码成功时执行)\n    \tconsole.log( res.data )\n\t})\n  \t.catch((err)=>{\n        if (err.response) {\n          // 服务器返回了一个非 2xx 的状态码时\n          console.log(err.response.data);\n          console.log(err.response.status);\n          console.log(err.response.headers);\n        } else if (err.request) {\n          // 发送请求时出错(没有发送成功)\n          console.log(err.request);\n        } else {\n          // 设置 axios 时出错(没有发送成功)\n          console.log('Error', err.message);\n        }\n        console.log(err.config);\n    }\n~~~\n\n\n\n## 发送自定义状态码\n\n上面的方式是在 HTTP 协议头中发送状态码信息，这种方式的缺点的是：`如果不是 2xx 的状态码，浏览器就会显示错误` 这样的用户体验不太好。\n\n我们可以在程序中无论正确与否都发送 200 状态码（成功），然后把错误的状态码信息放到我们自定义的数据中返回给前端，然后前端通过我们定义的状态码来判断对错，这样浏览器就不会显示错误信息了：\n\n比如：我们可以在项目中定义两个函数，成功时调用 ok 向前端发数据 ，调用时使用 error 向后端发消息：\n\n~~~php\nfunction ok($data)\n{\n    return [\n        'status_code' => 200,\n        'message'=>'ok',\n        'data' => $data\n    ];\n}\nfunction error($error, $code)\n{\n    static $_http_code = [\n        400 => \"Bad Request\",                  // 请求数据有问题\n        401 => \"Unauthorized\",                 // 未登录\n        403 => \"Forbidden\",                    // 登录但没有权限\n        404 => \"Not Found\",                    // 请求数据没找到\n        422 => \"Unprocessable Entity\",         // 无法处理输入的数据\n    ];\n    return [\n        'status_code' => $code,\n        'message' => $_http_code[$code],\n        'errors' => $error\n    ];\n}\n~~~\n\n然后在程序中我们可以这样显示数据：\n\n~~~php\nclass TestController extends Controller\n{\n    public function test(Request $req) {\n\n        $validator = Validator::make($req->all(), [\n            'title' => 'required|unique:posts|max:255',\n            'body' => 'required',\n        ]);\n\n        if ($validator->fails()) {\n            return error($validator->errors(), 422);\n        }\n\n        return ok([\n            'name' => 'tom',\n            'age' => 20,\n        ]);\n    }\n}\n~~~\n\n这时前端收到的消息时，同样返回了 422 错误的状态码，只不过这次不是在 http 协议头中返回的，是在我们正常的数据中返回的，这样浏览器就不会显示错误信息了：\n\n![](http://h.hiphotos.baidu.com/image/%70%69%63/item/b17eca8065380cd7b67ba266ac44ad34588281d7.jpg)\n\n\n\n## 在 Laravel 框架中添加自定义函数\n\n有时我们为了让 Laravel 框架更加的好用，我们会向框架中添加一些自定义的函数，那么这些自定义的函数应该放在哪里？其实，我们可以这样做：\n\n1、创建 `app\\helpers.php` 文件保存我们自定义的函数\n\napp\\helpers.php\n\n~~~php\n<?php\nfunction ok($data)\n{\n    return [\n        'status_code' => 200,\n        'message'=>'ok',\n        'data' => $data\n    ];\n}\nfunction error($error, $code)\n{\n    static $_http_code = [\n        400 => \"Bad Request\",                  // 请求数据有问题\n        401 => \"Unauthorized\",                 // 未登录\n        403 => \"Forbidden\",                    // 登录但没有权限\n        404 => \"Not Found\",                    // 请求数据没找到\n        422 => \"Unprocessable Entity\",         // 无法处理输入的数据\n        500 => \"Internal Server Error\",         // 服务器内部错误\n    ];\n    return [\n        'status_code' => $code,\n        'message' => $_http_code[$code],\n        'errors' => $error\n    ];\n}\n~~~\n\n\n\n2、修改 composer.json 添加自动加载项\n\ncomposer.json\n\n~~~json\n\"autoload\": {\n    ...\n    \"files\": [\n        \"app/helpers.php\"\n    ]\n},\n~~~\n\n\n\n3、命令行中执行加载指令\n\n~~~\ncomposer dump-auto\n~~~\n\n\n\n4、重新启动 Laravel 框架然后就可以在项目中直接使用 `app\\helpers.php` 文件中定义的函数了。\n\n\n\n## 表单验证\n\n因为 Laravel 框架中的表单验证默认的行为是 `验证失败就跳转回上一个页面` ，而在做接口开发时我们需要返回 JSON 数据而不是跳转，这时我们有多种解决办法，比如：我们可以采用 `手动验证` 的方式来验证数据，然后自己来控制在验证失败时返回 JSON 数据：\n\n~~~php\n// 自己创建验证器\n$validator = Validator::make($req->all(), [\n            'name' => 'required',\n            'tel' => 'required|regex:/^1[34578][0-9]{9}$/',\n            'province' => 'required',\n            'city' => 'required',\n            'area' => 'required',\n            'address' => 'required',\n            'is_default' => 'required',\n        ]);\n\n// 如果验证失败返回 json 数据\nif ($validator->fails()) {\n    return error($validator->errors(), 422);\n}\n~~~\n\n\n\n## JWT\n\n在 Laravel 框架中我们可以使用 `php-jwt` 这个扩展包来生成、验证、解析令牌。\n\n\n\n### 生成令牌\n\n1、安装扩展包\n\n```\ncomposer require firebase/php-jwt\n```\n\n2、.env 中定义加密密钥\n\n.env\n\n```\nJWT_KEN=fdsa32@#RFSDafpeq3r2fews8d783f;fa/fd293f\nJWT_EXPIRE=7200\n```\n\n3、生成令牌\n\n```php\nuse Firebase\\JWT\\JWT;\n...\n    \n// 读取密钥\n$key = env('JWT_KEY');\n// 当前时间戳\n$now = time();\n// 加密数据\n$data = array(\n    \"iat\" => $now,     \t\t\t\t\t    // 当前时间\n    \"exp\" => $now + env('JWT_EXPIRE'),      // 过期时间\n    \"id\" => 1,                              // 用户ID\n    // 其它需要保存的数据 ...\n);\n// 生成 JWT\n$jwt = JWT::encode($data, $key);\n```\n\n\n\n### 令牌验证\n\n在 Laravel 框架中我们可以使用中间件来验证、解析令牌，然后将解析之后的数据保存到 `$request->jwt` 属性中，然后在项目中就可以使用 `$request->jwt` 来获取 JWT 中的数据了。\n\n1、创建中间件\n\napp\\Http\\Middleware\\Jwt.php\n\n```php\n<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse \\Firebase\\JWT\\JWT as JWTCHECK;\n\nclass Jwt\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @return mixed\n     */\n    public function handle($request, Closure $next)\n    {\n        $jwt = substr($request->server('HTTP_AUTHORIZATION'), 7);\n        try\n        {\n            $request->jwt = JWTCHECK::decode($jwt, env('JWT_KEY'), array('HS256'));\n            return $next($request);\n        }\n        catch(\\Exception $e)\n        {\n            return response([\n                'code'=>'403',\n                'message'=>'HTTP/1.1 403 Forbidden'\n            ]);\n        }\n    }\n}\n```\n\n2、注册中间件\n\napp\\Http\\Kernel.php\n\n```php\nprotected $routeMiddleware = [\n    'auth' => \\App\\Http\\Middleware\\Authenticate::class,\n    'auth.basic' => \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\n    'bindings' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n    'cache.headers' => \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class,\n    'can' => \\Illuminate\\Auth\\Middleware\\Authorize::class,\n    'guest' => \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\n    'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\n    'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\n    'verified' => \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,\n    'jwt' => \\App\\Http\\Middleware\\Jwt::class,\n];\n```\n\n3、注册路由时使用中间件\n\nrouters/api.php\n\n```php\nRoute::post('/login', 'MemberController@login');\n\n// 应用 jwt 中间件的路由\nRoute::middleware(['jwt'])->group(function () {\n    Route::get('/orders', 'OrderController@index');\n});\n```\n\n\n\n# 接口实现\n\n接下来我们学习一下如何使用 Laravel 框架实现接口的开发。\n\n\n\n## 配置\n\n首先我们需要修改 `.env` 文件配置上数据库的账号：\n\n~~~\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=jxshop\nDB_USERNAME=root\nDB_PASSWORD=123456\n~~~\n\n\n\n配置好之后注意：`需要重新启动服务`。\n\n\n\n## 注册接口\n\n1、首先我们在 `postman` 软件中定义接口的名称、地址、参数等信息：\n\n![](http://h.hiphotos.baidu.com/image/%70%69%63/item/267f9e2f07082838c8e4dc9fb599a9014d08f154.jpg)\n\n说明：\n\n- 编写接口是先创建集合，然后再创建二级目录来管理接口（接口多时好找）\n- 接口是 post 时需要在 `body` 中设置需要提交的数据，一般使用 `x-www-form-urlencoded` 方式提交数据\n- 通过环境变量来管理常用的数据，比如使用 `host` 变量保存接口地址\n\n\n\n2、创建环境变量\n\n在使用 postman 测试接口时，有些数据使用的频率比较高，比如：服务器地址、令牌等，这时我们就可以定义环境变量来保存这些数据，方便修改和维护。\n\n打开环境变量管理面板：\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/9d82d158ccbf6c81e8d22c63b13eb13532fa4057.jpg)\n\n添加一套环境变量：\n\n![](http://h.hiphotos.baidu.com/image/%70%69%63/item/4610b912c8fcc3ce44ebcab89f45d688d43f2015.jpg)\n\n\n\n输入环境变量的名字以及定义的变量和值：\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/4b90f603738da977fcce86a0bd51f8198718e35c.jpg)\n\n创建之后选择使用环境变量：\n\n![](http://b.hiphotos.baidu.com/image/%70%69%63/item/7dd98d1001e9390118248eb576ec54e736d19612.jpg)\n\n接口写好之后就可以在 Laravel 中编写代码实现接口了。\n\n\n\n3、配置路由\n\n`routes/api.php`\n\n~~~php\nRoute::post('members', 'MemberController@insert');\n~~~\n\n\n\n4、创建模型\n\n使用 artisan 指令创建模型并保存到 Models 目录中：\n\n~~~\nphp artisan make:model Models/Member\n~~~\n\n模型中配置基本信息：\n\napp\\Models/Member.php\n\n~~~php\n<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Member extends Model\n{\n    // 对应的表单\n    protected $table = 'members';\n    // 表中是否有两个时间字段（created_at和updated_at)\n    public $timestamps = true;\n    // 设置允许填充的字段\n    protected $fillable = ['username','password'];\n    // 需要隐藏的字段（不会发给前端的字段）\n    protected $hidden = ['password','updated_at','created_at'];\n}\n~~~\n\n\n\n5、创建控制器\n\n~~~\nphp artisan make:controller MemberController\n~~~\n\napp\\Controller\\MemberController.php\n\n~~~php\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Validator;\nuse App\\Models\\Member;\n\nclass MemberController extends Controller\n{\n    public function insert(Request $req)\n    {\n        // 生成验证器对象\n        // 参数一、表单中的数据\n        // 参数二、验证规则\n        $validator = Validator::make($req->all(), [\n            'username'=>'required|min:6|max:18|unique:members',\n            'password'=>'required|min:6|max:18|confirmed',\n        ]);\n\n        // 如果失败\n        if($validator->fails())\n        {\n            // 获取错误信息\n            $errors = $validator->errors();\n            // 返回 JSON 对象以及 422 的状态码\n            return error($errors, 422);\n        }\n\n        // 插入数据库\n        // 返回值：插入成功之后那条记录的对象\n        $member = Member::create([\n            'username' => $req->username,\n            'password' => bcrypt($req->password),\n        ]);\n\n        return ok($member);\n\n    }\n}\n~~~\n\n\n\n6、在 postman 中测试接口\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/b812c8fcc3cec3fd740fa4fedb88d43f87942703.jpg)\n\n保存返回的结果（失败、成功的结果都保存一份）：\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/48540923dd54564ef257e7b2bede9c82d1584f0e.jpg)\n\n7、发布文档\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/09fa513d269759eecd186340bffb43166c22dff5.jpg)\n\n\n\n## 登录接口\n\n1、postman 中定义接口地址、参数等\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/4afbfbedab64034fca99c18da2c379310b551de0.jpg)\n\n2、定义路由\n\nroutes/api.php\n\n~~~php\nRoute::post('authorizations', 'MemberController@login');\n~~~\n\n\n\n3、控制器中添加登录方法\n\napp\\Http\\Controllers\\MemberController.php\n\n~~~php\npublic function login(Request $req)\n{\n    $validator = Validator::make($req->all(), [\n        'username'=>'required|min:6|max:18',\n        'password'=>'required|min:6|max:18',\n    ]);\n    if($validator->fails())\n    {\n        // 获取错误信息\n        $errors = $validator->errors();\n        // 返回 JSON 对象以及 422 的状态码\n        return error($errors, 422);\n    }\n\n    // 根据用户名查询账号是否存在 （只查询一条用 first 方法）\n    $member = Member::select('id','password')->where('username',$req->username)->first();\n    if($member)\n    {\n        // 判断密码\n        if(Hash::check($req->password, $member->password))\n        {\n            // 把用户的信息保存到令牌（JWT）中，然后把令牌发给前端\n            $now = time();\n            // 读取密钥\n            $key = env('JWT_KEY');\n            // 过期时间\n            $expire = $now + env('JWT_EXPIRE');\n            // 定义令牌中的数据\n            $data = [\n                'iat' => $now,        // 当前时间\n                'exp' => $expire,     // 过期时间\n                'id' => $member->id,\n            ];\n            // 生成令牌\n            $jwt = JWT::encode($data, $key);\n\n            // 发给前端\n            return ok([\n                'ACCESS_TOKEN' => $jwt,\n            ]);\n        }\n        else\n        {\n            return error('密码不正确！', 400);\n        }\n    }\n    else\n    {\n        return error('用户名不存在！', 404);\n    }\n}\n~~~\n\n4、下载 JWT 的包\n\n登录时需要 JWT 令牌机制，所以需要先安装一个解析 JWT 的包：\n\n~~~\ncomposer require firebase/php-jwt\n~~~\n\n\n\n5、配置 JWT\n\n.env  文件中定义 jwt 的密钥和过期时间 \n\n~~~\nJWT_KEN=fdsa32@#RFSDafpeq3r2fews8d783f;fa/fd293f\nJWT_EXPIRE=7200\n~~~\n\n\n\n6、保存示例结果\n\n在 Postman 中把几种不同情况的返回结果都保存起来：\n\n![](http://b.hiphotos.baidu.com/image/%70%69%63/item/37d12f2eb9389b500e57e3d98835e5dde6116e94.jpg)\n\n登录成功时返回令牌：\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/91ef76c6a7efce1bd7bbcb41a251f3deb58f65ac.jpg)\n\n\n\n\n\n# 令牌的验证\n\n前端在登录成功之后，会得到令牌，然后需要把得到的令牌保存到本地，之后在请求需要验证的接口时（比如下单）需要把这个令牌在 HTTP 协议头中发送到服务器端，以进行令牌验证。\n\n\n\n## 服务器端验证\n\n我们可以使用 Laravel 框架的中间件来实现令牌的验证。\n\n1、创建中间件\n\n~~~\nphp artisan make:middleware Jwt\n~~~\n\n并编写中间件代码:\n\n~~~php\n<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse \\Firebase\\JWT\\JWT as JWTCHECK;\n\nclass Jwt\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @return mixed\n     */\n    public function handle($request, Closure $next)\n    {\n\n        /* 说明：客户端在提交令牌时，是把令牌放到 http 协议头中（不是表单中！！）\n                并且 JWT 规定前7个字符必须是 bearer （后面这里有个空格）\n            HTTP_AUTHORIZATION: bearer fdkl;ajsf;dsajlfjl;jxxxxx\n            所以我们在获取令牌时，要从 $_SERVER 中获取，不是 $_POST\n            在 Laravel 中要获取 $_SERVER 使用  $request->server 函数\n        */\n        // 从协议头是取出令牌\n        $jwt = substr($request->server('HTTP_AUTHORIZATION'), 7);\n        try\n        {\n            // 解析 token\n            $jwt = JWTCHECK::decode($jwt, env('JWT_KEY'), array('HS256'));\n            // 把解析出来的数据保存到 Request 对象中的 jwt 属性上，将来在控制器中就可能 $req->jwt 这样来获取了\n            $request->jwt = $jwt;\n\n            // 继续执行下一个中间件\n            return $next($request);\n        }\n        catch(\\Exception $e)\n        {\n            // 返回错误信息\n            return response([\n                'code'=>'403',\n                'message'=>'HTTP/1.1 403 Forbidden'\n            ]);\n        }\n    }\n}\n~~~\n\n2、注册中间件到路由中间件组中\n\napp\\Http\\Kernel.php\n\n~~~php\nprotected $routeMiddleware = [\n    'auth' => \\App\\Http\\Middleware\\Authenticate::class,\n    'auth.basic' => \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\n    'bindings' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n    'cache.headers' => \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class,\n    'can' => \\Illuminate\\Auth\\Middleware\\Authorize::class,\n    'guest' => \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\n    'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\n    'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\n    'verified' => \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,\n    'jwt' => \\App\\Http\\Middleware\\Jwt::class,\n];\n~~~\n\n\n\n3、在定义路由时应用中间件\n\nroutes/api.php\n\n先定义一个路由组，然后对组应用 jwt 中间件，所有这个组中的路由都会先验证令牌\n\n~~~php\nRoute::middleware(['jwt'])->group(function () {\n\n    Route::post('orders', 'MemberController@order');\n\n});\n~~~\n\n\n\n4、控制器中获取令牌数据\n\n因为在中间件中我们已经把解析令牌的数据保存到 Request 对象的 jwt 属性中了，所以在控制器中可以直接使用 `$req->jwt` 来获取令牌中的数据：\n\n~~~php\npublic function order(Request $req)\n{\n    // 获取令牌中的数据\n\n    echo $req->jwt->id;\n}\n~~~\n\n\n\n\n\n\n\n## Postman 中设置令牌\n\n当使用 Postman 来请求需要验证的接口时，需要先在 Postman 中设置令牌，否则 会请求失败。\n\n1、先使用正确的账号和密码登录成功得到一个令牌\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/03087bf40ad162d9104961971cdfa9ec8b13cd92.jpg)\n\n\n\n2、把令牌保存到环境变量中\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/c2cec3fdfc0392455c0ae2848a94a4c27c1e25f9.jpg)\n\n\n\n3、在需要令牌的接口上设置 authorzation\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/63d9f2d3572c11df4c72bca86e2762d0f603c29e.jpg)\n\n\n\n这时就可以正常的访问令牌了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["PHP"]},{"title":"Docker 基本使用","url":"/2018/06/17/docker/","content":"# docker\n\nDocker 是一个开源的应用容器引擎。\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/d50735fae6cd7b8933b62508022442a7d8330e66.jpg)\n\n\n\n## 特点\n\n- 环境一次安装，到处运行\n\n我们可以把配置好的环境制作成一个镜像，这个镜像就可以在所有安装了 Docker 的机器上直接运行。当我们需要为几台、几十台甚至几百台服务器安装环境时，我们只需要制作一个镜像，然后所有服务器就可以使用这个镜像启动服务了。\n\n\n\n- 与虚拟机的关系\n\nDocker 是`容器技术`，和虚拟机非常像，都可以在主机上隔离出多个独立的子系统，它们最大的区别在于虚拟机是从主机中完全隔离出一个系统来，而容器技术和主机是共享系统内核的。\n\n\n\n![](http://e.hiphotos.baidu.com/image/%70%69%63/item/d0c8a786c9177f3ee3fce2867dcf3bc79e3d5674.jpg)\n\n\n\n\n\n由于 Docker 与主机共享内核，所以有以下优势：\n\n1、速度更快\n\n​\tDocker不停地给大家宣传，\"虚拟机需要数分钟启动，而Docker容器只需要50毫秒\"。\n\n2、更加轻量\n\n​\t虚拟机中每个都是一套独立的系统，这就使得每个虚拟机都非常大，而 Docker 使用了分层的技术，不同的镜像之间可以同享相同的层，这使得容器尺寸很小。\n\n3、更节省资源\n\n​\t启动一个虚拟机，就要启动它内部的操作系统，这非常消耗资源，一台电脑上同时开启3~10个虚拟机电脑就已经完全跑不动了。\n\n​\t而 Docker 是共享主机内核，所以启动一个 Docker 就和启动一个普通的程序一样，所以我们可以同时在电脑上开启上千个 Docker 容器。\n\n\n\n## Docker 化\n\n有了 Docker 之后，我们就可以将我们的程序 Docker 化。\n\nDocker 化就是指将开发的系统制作成一个镜像，当要要新的机器上部署该项目时，只需要拉取镜像然后就可以直接创建容器来运行了，这样就省了重新安装运行环境的步骤了（在一台新的机器上搭建运行环境是非常麻烦的事情）。\n\n\n\n\n\n## 安装\n\nDocker 可以安装、运行在常见的 Linux 系统上，而对于 Windows 和 Mac 系统也有办法安装上。\n\nWindows：如果是 Windows10专业版，可以直接安装，如果是老的版本需要安装Docker虚拟机。\n\n安装之后，可以在命令行中执行 `docker` 指令：\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/eaf81a4c510fd9f9c2664ce2282dd42a2934a4c3.jpg)\n\n\n\n\n\n\n\n# 使用 Docker\n\n\n\n## 几个概念\n\n镜像（image）：已经打包好的 Docker 应用，有点类似于一个程序的安装包。\n\n镜像仓库：存储镜像的服务器。\n\n容器：有了镜像我们就可以创建容器了，容器就是运行着的镜像，一个镜像可以同时创建多个容器，容器之间的隔离的。\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/e7cd7b899e510fb3a2276e1cd433c895d1430c7a.jpg)\n\n\n\n## 常用指令\n\n\n\n| 指令                        | 说明                                 |\n| --------------------------- | ------------------------------------ |\n| docker images               | 查看已下载的镜像                     |\n| docker rmi 镜像名称:标签名  | 删除已下载的镜像                     |\n| docker search 镜像          | 从官方仓库（hub.docker.com）查找镜像 |\n| docker pull 镜像名称:标签名 | 标签名默认是 latest，代表最新版本。  |\n| docker run                  | 创建容器                             |\n| docker ps                   | 列出运行中的容器（运行中）           |\n| docker ps -a                | 列出未运行的容器                     |\n| docker rm 容器名称          | 删除停止的容器                       |\n| docker rm -f 容器名称       | 删除运行中的容器                     |\n| docker start 容器名称       | 启动容器                             |\n| docker stop 容器名称        | 停止容器                             |\n| docker restart 容器名称     | 重启容器                             |\n| docker exec                 | 执行容器中的指令                     |\n\n\n\n## 创建容器\n\n下载了镜像之后，我们就可以通过镜像来创建容器，创建容器时常用的参数是：\n\n~~~\ndocker run --name 容器名称 -d -p 主机端口:容器内端口 -e 环境变量 --link 其它容器名:容器中别名 镜像名称:标签名\n~~~\n\n参数说明：\n\n--name：指定容器名称\n\n-d：容器在后台运行\n\n-p：绑定端口号，容器内部的端口号无法在外部访问，必须经过绑定之后才可以访问\n\n--link：连接其它容器，当要访问其它容器中的内容时，需要先链接才可以使用\n\n-e：设置容器中的环境变量\n\n\n\n示例：创建一个 MySQL 容器，密码是123123，绑定本地 33306 端口到容器中 3306 端口：\n\n~~~\ndocker run --name mysql001 -d -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24\n~~~\n\n说明：MYSQL_ROOT_PASSWORD 环境变量用来设置这个容器中 MySQL 的密码\n\n\n\n创建之后，会启动这个容器，如果启动成功，就可以使用 `docker ps` 指令查看到：\n\n![](http://h.hiphotos.baidu.com/image/%70%69%63/item/1ad5ad6eddc451da1e4f1560bbfd5266d11632fb.jpg)\n\n启动之后，这个容器内部就运行了 MySQL 服务器，在容器内部监听的是 3306 端口，我们已经将这个端口绑定到了主机的 33306 端口上，所以我们在主机上可以使用 33306 端口连接：\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/b03533fa828ba61ed059d1a44c34970a314e5981.jpg)\n\n## 进入容器\n\n有时我们需要进入到一个容器内部去操作这个容器，这时我们可以使用 `docker exec` 指令来实现。\n\ndocker exec 指令可以执行一个运行着的容器中的命令：\n\n~~~\ndocker exec -it 容器名称 命令\n~~~\n\n我们可以通过执行 `bash` 指令进入容器：\n\n~~~\ndocker exec -it mysql001 bash\n~~~\n\n或者\n\n~~~\ndocker exec -it mysql001 /bin/sh\n~~~\n\n-it：以实时交互的形式运行（和 -d 正好相反）\n\n\n\n执行之后就进入到了容器中，然后我们输入的命令是在容器中执行的\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/e850352ac65c10387bb2d749bf119313b17e8968.jpg)\n\n\n\n执行 `exit` 指令可以退出容器。\n\n\n\n## 链接容器\n\nDocker 推荐我们一个容器中只运行一个主要的应用程序，比如，我们要运行一个 PHP + MySQL 的程序，那么我们应该把 PHP 和 MySQL 放到两个容器中：\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/b3119313b07eca80487a216c9c2397dda1448339.jpg)\n\n默认情况下，容器之间是不能直接通信的，如果要通信必须在创建 PHP 容器时使用 `--link` 参数建立和 MySQL 容器的链接：\n\n![](http://b.hiphotos.baidu.com/image/%70%69%63/item/09fa513d269759eec4067840bffb43166c22dfe3.jpg)\n\n建立连接的参数说明：\n\n~~~\n--link 要连接的容器的名称 : 别名\n~~~\n\n在容器中可以使用别名来访问连接的容器。\n\n\n\n比如，我们现在运行了一个叫做 `mysql001` 的容器，现在我们要创建一个 PHP 容器并和 MySQL 容器建立链接，指令应该是：\n\n创建一个 PHP 容器，并且设置和 mysql001 容器建立连接，在 PHP 容器中连接的别名是 mysql\n\n~~~\ndocker run --name php001 -d --link mysql001:mysql            php\n~~~\n\n创建了链接之后，就可以在容器中使用别名来通信了：\n\n~~~php\n// 连接 mysql001 容器中的 MySQL 服务器\n$pdo = new PDO('mysql:host=mysql:3306;dbname=xxx', 'root', '123123')\n~~~\n\n\n\n扩展：我们可以同时添加多个 --link 来同时连接多个容器，比如同时连接mysq001和redis001两个容器：\n\n~~~\ndocker run --name php001 -d --link mysql001:mysql --link redis001:redis php\n~~~\n\n\n\n\n\n\n\n示例：安装 wordpress（一个开源的使用 PHP+MYQS 开发的内容管理系统 ）\n\n~~~\ndocker run --name wordpress --link mysql001:mysql -p 8080:80 -d wordpress\n~~~\n\n创建 wordpress 容器时，发现本地没有镜像就会自动下载最新的镜像，下载完之后就创建了容器，然后我们就可以在浏览器中访问 8080 端口：\n\n![](http://c.hiphotos.baidu.com/image/%70%69%63/item/d50735fae6cd7b8934d92208022442a7d8330e87.jpg)\n\n这样，我们就使用部署 wordpress 到我们的电脑上了。\n\n\n\n\n\n## 挂载硬盘\n\n问题一、数据是保存在容器里的，如果容器删除了数据也就删除了。\n\n问题二、每次要修改容器时，必须要进入到容器中去修改，比如要修改my.cnf。\n\n\n\n为了能够保存（持久化）数据以及共享容器间的数据，Docker 提出了 Volume 的概念。\n\n可以使用 `-v` 这个参数，将容器中的一个目录或者文件 和主机上的目录和文件进行绑定，绑定之后，修改主机上的这个文件就相当于修改了容器中的文件，删除容器之后，绑定的目录和文件还在主机（不会被删除）。\n\n\n\n为了实现主机和容器之间的数据共享，我们可以在创建容器时添加 `-v` 参数：\n\n~~~\ndocker run ... -v 主机目录:容器中的目录 ...\n~~~\n\n示例：创建 mysql 容器并将数据目录挂载到主机：\n\n~~~\ndocker run --name mysql002 -d -v /Users/wyl/Works/code/docker-volume-data/testmysql:/var/lib/mysql -p 33307:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24\n~~~\n\n\n\n示例：启动一个 Nginx 服务器并将 nginx 的主目录搭载到主机上\n\n1、下载 nginx\n\n~~~\ndocker pull nginx:1.15.6-alpine\n~~~\n\n2、到容器中查看网站根目录的路径\n\n~~~\ndocker run --name testnginx -d nginx:1.15.6-alpine   ## 创建容器\ndocker exec -it testnginx /bin/sh                    ## 进入容器\n~~~\n\n在容器中使用 vi 编辑器查看配置文件：\n\n~~~\nvi /etc/nginx/conf.d/default.conf\n~~~\n\n查看网站根目录是 `usr/share/nginx/html`。\n\n删除该容器\n\n~~~\ndocker rm -f testnginx\n~~~\n\n3、创建 nginx 容器并将 `/usr/share/nginx/html` 挂载到本地\n\n~~~\ndocker run --name nginx001 -d -p 30080:80 -v 本地目录:/usr/share/nginx/html nginx.1.15.6-alpine\n~~~\n\n\n\n\n\n## 复制文件\n\n我们可以使用 `docker cp` 指令向容器中复制文件，或者从容器中复制文件到主机。\n\n\n\n~~~\ndocker cp 源目录  目标目录\n~~~\n\n\n\n- 复制主机文件到容器\n\n~~~\ndocker cp C:/my.cnf mysql001:/etc/mysql/my.cnf\n~~~\n\n\n\n- 从容器复制文件到主机\n\n~~~\ndocker cp  mysql001:/etc/mysql/my.cnf C:/my.cnf\n~~~\n\n\n\n# 综合案例、使用 Docker 搭建 LNMP 环境\n\n我们平时在做开发时，为了简单、方便我们常用以下开发环境：\n\n1、WAMP\n\n2、Visual AMP\\NMP\n\n3、PHP 内置 WEB 服务器，如 `php -S localhost:9999 -t` 还有 Laravel 中的 `php artisan serve --port 8001` 。\n\n以上这三种只适用于开发时使用，在真正的线上环境我们需要安装更加稳定并且能够支撑高并发的运行环境，目前 PHP 的生产环境最常用的就是 `LNMP`。\n\nLNMP：Linux + Nginx + MySQL + PHP\n\n\n\n## Nginx\n\nNginx 是目前最流行的高性能、高并发的开源、免费的 WEB 服务器，俄国斯的开发。\n\n![](http://f.hiphotos.baidu.com/image/%70%69%63/item/a044ad345982b2b7e533214f3cadcbef77099b88.jpg)\n\nNginx 使用 Linux 中最流行的 `epoll` 做为事件处理机制，并且 Nginx 在运行时只消耗极少的系统资源，所以可以轻松实现上万的并发请求，Nginx 除了可以做为 WEB 服务器之外，还可以做为Email、反向代理、负载均衡、流媒体等服务器。\n\nNginx 和其它脚本语言（如PHP）一起工作时一般使用 FastCGI 机制。\n\n\n\n## 方案\n\n方案一、一个容器中同时 nginx php-mpm \n\n​\t好处：简单、方便\n\n​\t缺点：不利于每个软件的横向扩展\n\n方案二、把 nginx、php-fpm、MySQL 分别放到三个容器中\n\n​\t好处：有利于单独扩展每个系统\n\n​\t缺点：部署相对复杂\n\n\n\n\n\n## LNMP 模型图\n\n创建三个容器：Nginx、PHP-FPM、MySQL，它们之间的关系是：\n\n（说明：图中端口可以任意修改）\n\n![](http://e.hiphotos.baidu.com/image/%70%69%63/item/ac4bd11373f08202eea88ab446fbfbedab641b06.jpg)\n\n\n\n总结：Nginx 负载处理静态文件，如果用户访问的是 PHP 文件，就转发给 PHP 服务器的9000来处理，PHP服务器处理完之后，把结果返回给 nginx,然后nginx再返回给前端。\n\n\n\n1、下载镜像\n\n下载 nginx 镜像（alpine版的更小）\n\n~~~\ndocker pull nginx:1.15-7-alpine\n~~~\n\n下载 MySQL 镜像\n\n~~~\ndocker pull mysql:5.27.24\n~~~\n\n下载 PHP-FPM 镜像\n\n~~~\ndocker pull php:7.2-fpm-alpine\n~~~\n\n\n\n![](http://d.hiphotos.baidu.com/image/%70%69%63/item/30adcbef76094b3697400366aecc7cd98c109d6e.jpg)\n\n\n\n2、创建容器\n\n我们创建三个容器 Nginx、PHP-FPM、MySQL，这里需要注意的是它们创建的顺序：\n\nMySQL => PHP-FPM => Nginx\n\n创建 MySQL 容器\n\n~~~\ndocker run --name mysql001 -d -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24\n~~~\n\n创建 php 容器\n\n~~~\ndocker run --name phpfpm7.2 -d --link mysql001:mysql php:7.2-fpm-alpine\n~~~\n\n创建 nginx 容器\n\n~~~\ndocker run --name nginx -d -p 8988:80 --link phpfpm7.2:php nginx:1.15.7-alpine\n~~~\n\n\n\n3、配置 Nginx\n\nNginx 只能对静态文件（html，css，js，图片等）进行处理，无法处理动态文件（php、python等），我们需要配置 nginx 将动态脚本转发给 PHP 服务器。\n\na. 进入 nginx 容器\n\n~~~\ndocker exec -it nginx /bin/sh\n~~~\n\n\n\nb、查找配置文件位置\n\n~~~\nfind / -name nginx.conf\n~~~\n\n\n\nc、修改 Nginx 的配置文件\n\n/etc/nginx/conf.d/default.conf\n\n~~~\nserver {\n    ...\n\n    location / {\n        root   /usr/share/nginx/html;    # 网站根目录\n        index  index.html index.htm;\n    }\n\n    ...\n    \n    location ~ \\.php$ { \n        fastcgi_pass   php:9000;         # 转发到 PHP 服务器的地址,PHP是容器的别名\n        fastcgi_index  index.php;        \n        fastcgi_param  SCRIPT_FILENAME  /php$fastcgi_script_name;  # 转发的文件名\n        include        fastcgi_params;                                \n    }   \n    \n    ...\n}\n~~~\n\n说明：\n\n$fastcgi_script_name ：代表当前访问的文件名，比如，如果访问的是 localhost/1.php ，那么这一项的值就是 1.php\n\n\n\nd、退出 nginx 容器并重新启该容器\n\n因为我们修改了 nginx 的配置文件，所以我们需要重启服务器\n\n~~~\ndocker restart nginx\n~~~\n\n\n\ne、进入 phpfpm 容器创建 /php 目录\n\n在 nginx 中我们配置了，当遇到 PHP 脚本时，就转发 `/php$fastcgi_script_name;` 这个路径到 php 容器，所以PHP会到它的 `/php` 目录下去查找，所以我们需要进入 PHP 创建中并创建这个目录。\n\n进入PHP容器\n\n~~~\ndocker exec -it phpfpm7.2 /bin/sh\n~~~\n\n进入容器之后，创建目录\n\n~~~\nmkdir /php\n~~~\n\n然后我们就可以在 /php 目录中创建  php 脚本了，这些脚本就可以通过浏览器运行访问了。\n\n\n\nNginx 运行PHP的流程：\n\n![](http://g.hiphotos.baidu.com/image/%70%69%63/item/d8f9d72a6059252dc248068f399b033b5ab5b9d9.jpg)\n\na、nginx 判断访问的文件以 .php 结尾\n\nb、nginx 将 /php/1.php 这个路径传给 PHP 的9000端口\n\nc、PHP接收到nginx传过来的路径，就在本机中读取这个文件并运行\n\nd、PHP将运行结果返回给 nginx\n\ne、NGINX将结果返回给用户\n\n\n\n## 两个问题\n\nlnmp环境搭建好了，但是还有些问题需要考虑\n\n1、为PHP容器中安装扩展\n\n我们使用的是 PHP 默认的镜像，这个镜像中缺少很多必要的 PHP 扩展，比如 gd、redis、pdo_mysql 等，这些扩展都需要单独安装。\n\n不过官方提供了安装扩展的两种方法：\n\n​\t核心扩展（pdo_mysql,gd等） 使用 docker-php-ext-install\n\n如安装 gd 库：(先进入PHP容器，然后执行以下命令)\n\n~~~\ndocker-php-ext-install gd\n~~~\n\n​\t\n\n​\t其它扩展（redis、yaf、swoole等）使用 pecl\n\n如安装 redis：(先进入PHP容器，然后执行以下命令)\n\n~~~\npecl install redis\ndocker-php-ext-enable redis\n~~~\n\n\n\n2、把两个容器代码的目录都绑定到一个目录中\n\n现在我们需要把静态页保存到 nginx 容器中，然后把 php 脚本写到 php 容器中，这样在放代码时比较麻烦，所以我们可以将两个服务器的代码目录都绑定到本机，这样直接在本机就可以编写代码了。\n\na、在本机创建一代码目录\n\nb、删除nginx容器重新创建一个新的容器\n\n~~~\ndocker run --name nginx -d -p 8988:80 -v 本地目录:/usr/share/nginx/html --link phpfpm7.2:php nginx:1.15.7-alpine\n~~~\n\n通过 -v 我们就把 nginx 中网站根目录绑定球果一地的目录 中了。\n\n创建 nginx 容器之后，重新向前面一样修改一下 `/etc/nginx/conf.d/default.conf` 配置文件，然后重新启动即可。\n\nc、删除PHP容器然后重新创建一个新的容器\n\n~~~\ndocker run --name phpfpm7.2 -d -v 本地目录:/php --link mysql001:mysql php:7.2-fpm-alpine\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Docker"]},{"title":"workerman 基本使用","url":"/2018/06/17/workerman/","content":"# WebSocket\n\n## 什么是 WebSocket\n\nWebSocket协议是基于 `TCP` 的一种新的 `网络协议`。\n\n它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n\n\n\n## WebSocket 和 HTTP 的区别\n\nHTTP协议的特点：\n\n​\t1、服务器只能响应客户端的请求，不能主动向客户端推送数据\n\n​\t2、客户端的每次请求都需要连接、断开，即每次请求都是一个全新的请求\n\nWebSocket的特点：\n\n​\t1、客户端与服务器端在连接时可以互相推据数据\n\n​\t2、客户端连接到服务器之后，会一直保持连接的状态，直到有一端主动断开连接\n\n\n\n## 应用范围\n\nWebSocket 一般用来开发`聊天室`、`网页游戏`等需要长连接并且可以双向通信的应用程序。\n\n![](http://e.hiphotos.baidu.com/image/%70%69%63/item/79f0f736afc37931b6e983a2e6c4b74542a911b3.jpg)\n\n\n## PHP 实现 WebSocket\n\n在 PHP 中实现 `WebSocket` 可以使用 `Swoole` 或者 `Workerman`。\n\nSwoole 和 Workerman 是两个 PHP 中使用的多进程 socket 服务器框架，支持HTTP、WebSocket、Tcp、Udp等多种协议。\n\nSwoole：是用 C 语言开发的 PHP 扩展，只能在 Linux 上使用，性能更好、上手有点难度。\n\nWorkerman：是用 PHP 开发的框架，windows 和 Linux 上都可以使用，无须安装下载即可使用、性能相对swoole弱一些，上手比较简单。\n\n\n\n\n\n# Workerman\n\n官方文档：[http://doc.workerman.net/](http://doc.workerman.net/)\n\n\n\n## 下载\n\nWorkerman 无须安装，下载、引入之后即可使用。\n\n下载地址：[https://www.workerman.net/download/workermanzip](https://www.workerman.net/download/workermanzip)\n\n\n\n\n\n## 引入\n\n下载之后直接引入使用：\n\n~~~php\n<?php\nuse Workerman\\Worker;\nrequire_once '下载目录/Workerman-master/Autoloader.php';\n// 实例化 Worker 类对象\n$worker = new Worker('websocket://0.0.0.0:8686');\n~~~\n\n\n\n## 核心类\n\nworkerman 中最核心的两个类是 `Worker` 和 `TcpConnection` 类。\n\nWorker：端口监听、启动服务、接收请求等。\n\nTcpConnection：负责管理每个连接的客户端，接收客户端信息，发送客户端信息等。\n\n\n\n### Worker\n\nWorker用来绑定端口、启动服务器。\n\n- 构造函数\n\n创建 Worker 时需要指定协议、IP和端口号。\n\n比如：启动 websocket 服务器，绑定到 8686 端口（1~65535，1000以 内的端口号留给系统）：\n\n```php\n$worker = new Worker('websocket://0.0.0.0:8686');\n```\n\n- 重要属性\n\nconnections：保存所有连接的客户端对象（TcpConnection类对象）的数组。\n\ncount：启动的进程数，默认是1（我们现在先只启动1个，启动多会出现多进程的问题）。\n\n- 回调函数\n\nonWorkerStart：当子进程启动时触发的函数，一般做一些初始化的功能，连接数据库等。\n\nonConnect：当有客户端连接成功时触发的函数。\n\nonMessage：当收到客户端的数据时触发的函数。\n\nonClose：当与客户端断开连接时触发的函数。\n\n- 接口\n\nrunAll：启动程序。\n\n示例代码：\n\nserver.php\n\n~~~php\n<?php\nuse Workerman\\Worker;\nrequire_once '../Workerman-master/Autoloader.php';\n// 启动时调用\nfunction start($worker)\n{\n\techo '启动成功！';\n}\n// 有连接时调用\nfunction connect($connection)\n{\n\techo '有客户端连接~';\n}\n// 当收到数据时调用\nfunction message($connection, $data)\n{\n\techo '收到消息'.$data;\n}\n// 当有客户端断开连接时调用\nfunction close($connection)\n{\n\techo '有客户端断开连接~';\n}\n// 绑定端口\n$worker = new Worker('websocket://0.0.0.0:8686');\n// 设置进程数为1\n$worker->count = 1; \n// 设置回调函数\n$worker->onWorkerStart = 'start';\n$worker->onConnect = 'connect';\n$worker->onMessage = 'message';\n$worker->onClose = 'close';\n// 启动\nWorker::runAll();\n~~~\n\n\n\n### TcpConnection\n\n每个客户端的连接就是一个 `TcpConnection` 类的对象，所以上面代码中的 `$connection` 就是 `TcpConnection` 这个类的对象，通过这个对象我们就可以获取客户端的信息，也可以向客户端发送数据。\n\n- 重要属性\n\nid：每个客户端都有一个 id，它是一个自增的整数，可以通过这个 id 来区别客户端。\n\nworker：当前这个连接所属的 worker 对象。\n\n- 接口\n\nsend：向客户端发送数据。\n\nclose：关闭与这个客户端的连接。\n\n\n\n示例代码、当收到消息时，把消息转发给所有其它的客户端：\n\n~~~php\n<?php\nuse Workerman\\Worker;\nrequire_once '../Workerman-master/Autoloader.php';\n// 启动时调用\nfunction start($worker)\n{\n\techo '启动成功！';\n}\n// 有连接时调用\nfunction connect($connection)\n{\n\techo '有客户端连接~';\n}\n// 当收到数据时调用\nfunction message($connection, $data)\n{\n    // 循环所有客户端\n    foreach($connection->worker->connections as $c)\n    {\n        // 如果不是自己就转发消息\n        if($connection->id != $c->id)\n        {\n            $c->send($data);\n        }\n    }\n}\n// 当有客户端断开连接时调用\nfunction close($connection)\n{\n\techo '有客户端断开连接~';\n}\n// 绑定端口\n$worker = new Worker('websocket://0.0.0.0:8686');\n// 设置进程数为1\n$worker->count = 1; \n// 设置回调函数\n$worker->onWorkerStart = 'start';\n$worker->onConnect = 'connect';\n$worker->onMessage = 'message';\n$worker->onClose = 'close';\n// 启动\nWorker::runAll();\n~~~\n\n\n\n## 启动、关闭\n\n与之前学习的程序不同 workerman 的程序是在命令行中运行的。\n\n可以使用以下指令启动、关闭程序：\n\n~~~\nphp server.php start      // 启动\nphp server.php stop       // 关闭程序\n~~~\n\n示例、启动（ server.php 为脚本的名字）\n\n![](http://g.hiphotos.baidu.com/image/%70%69%63/item/838ba61ea8d3fd1f37f6a7b13d4e251f94ca5fb9.jpg)\n\n\n\n# 客户端\n\n使用 PHP 启动了 WebSocket 服务器之后，会在服务器上监听一个端口号（上面代码中的 8686）。有了服务器之后，我们就可以编写前端代码连接服务器进行数据通信。\n\n\n\n客户端可以是任何一个支持 `WebSocket` 协议的软件，我们常用的就是浏览器。\n\n在浏览器中编写代码自然是使用 `JavaScript` 语言了。\n\n\n\n## JS 中的 WebSocket\n\n使用 JavaScript 实现 WebSocket 非常的简单，只需要以下几步：\n\n1、连接服务器\n\n2、绑定回调函数接收、处理数据\n\n3、调用 send 方法发送数据\n\n\n\n## 连接服务器\n\nJS 中提供了一个 WebSocket 类，可以通过 new 来连接服务器，连接时需要指定服务器的IP地址和端口号：\n\n~~~js\nvar ws = new WebSocket('ws://ip:端口号');\n~~~\n\n\n\n## 绑定回调函数\n\n连接了服务器之后，我们需要绑定几个回调函数，来处理相应的事件：\n\nonopen：当连接成功时触发。\n\nonmessage：当收到消息时触发。\n\nonclose：当与服务器断开连接时触发。\n\n~~~js\n// 连接服务器成功时触发\nws.onopen = function() {\n    console.log(\"连接成功\")\n}\n// 收到服务器消息时触发\nws.onmessage = function(e) {\n    console.log(\"收到服务端的消息：\" + e.data)\n}\n// 与服务器断开连接时触发\nws.onclose = function(e) {\n    console.log(\"与服务器断开连接\")\n}\n~~~\n\n\n\n## 方法\n\n可以调用 `send` 方法向服务器发送数据，也可以调用 `close` 方法断开和服务器的连接：\n\n~~~js\nws.send('Hello Tom')   // 向服务器发送数据\nws.close();        // 断开连接\n~~~\n\n\n\n示例代码：\n\nclient.html\n\n~~~html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>WebSocket 客户端</title>\n</head>\n<body>\n</body>\n</html>\n<script>\nws = new WebSocket(\"ws://127.0.0.1:8686\")\nws.onopen = function() {\n    console.log(\"连接成功\")\n    ws.send('tom')\n    console.log(\"给服务端发送一个字符串：tom\")\n}\nws.onmessage = function(e) {\n    console.log(\"收到服务端的消息：\" + e.data)\n    ws.close();\n}\nws.onclose = function(e) {\n    console.log(\"与服务器断开连接\")\n}\n</script>\n~~~\n\n\n\n前、后端图解：\n\n![](http://d.hiphotos.baidu.com/image/%70%69%63/item/9213b07eca8065382711a1989adda144ac348245.jpg)\n\n\n\n# 连接时传递参数\n\n有时，我们希望在客户端连接服务器时就传递一些参数，这时可以这样做：\n\n客户端在连接时通过 GET 方式传递参数：\n\n~~~js\nws = new WebSocket('ws://127.0.0.1:8686?name=tom&age=10')\n~~~\n\n服务器端在连接时接收参数：\n\n~~~php\n$worker-onConnect=function($connection)\n{\n    $connection->onWebSocketConnect = function ($connection, $http_header) {\n     \t\n        // 使用 $_GET 接收参数：\n        echo $_GET['name'];\n        echo $_GET['age'];\n        \n    };\n}\n~~~\n\n\n\n# 案例、聊天室：群聊天\n\n核心思路：使用 Worker 类的 connections 属性可以得到保存所有客户端 $connection 对象的数组，然后我们可以循环这个数组调用每个客户端的 send 方法给每个客户端发消息。\n\n服务器端：server.php\n\n~~~php\n<?php\n\n/*\nWebSocket 的服务器端\n*/\n\nuse Workerman\\Worker;\nrequire_once '../Workerman-master/Autoloader.php';\n// 实例化 Worker 类对象\n$worker = new Worker('websocket://0.0.0.0:8686');\n// 设置进程数\n$worker->count = 1;\n// 设置回调函数\n\n// 绑定连接的回调函数，这个函数会在有客户端连接时调用\n// 参数：TcpConnection 类的对象，代表每个客户端\n$worker->onConnect = function( $connection ) {\n    // 向这个客户端发数据\n    $connection->send('欢迎您~');\n};\n\n// 接收消息\n$worker->onMessage = function($connection, $data) {\n    global $worker;\n    // 循环所有的客户端，给它们发消息\n    foreach($worker->connections as $c)\n    {\n        $c->send($data);\n    }\n};\n\n// 运行\nWorker::runAll();\n~~~\n\n客户端：index.html\n\n~~~html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <ul>\n            <li v-for=\"(v,k) in messages\">\n                有人说：{{v}}\n            </li>\n        </ul>\n        <textarea v-model=\"content\"></textarea>\n        <input @click=\"submit\" type=\"button\" value=\"发送\">\n    </div>\n</body>\n</html>\n<script src=\"vue.min.js\"></script>\n<script>\n\nnew Vue({\n    el:'#app',\n    data: {\n        ws: null,  // 保存 WebSocket 对象\n        content:'',\n        messages: []  // 保存所有接收的消息\n    },\n    // 当 vue 创建时调用\n    created: function(){\n        this.ws = new WebSocket('ws://127.0.0.1:8686')\n        this.ws.onopen = this.open\n        this.ws.onmessage = this.message\n    },\n    methods:{\n        submit:function(){\n            // 把框里的内容发送到服务器\n            this.ws.send( this.content )\n            // 清空框\n            this.content = ''\n        },\n        open: function() {\n            alert('连接成功！')\n        },\n        message: function(e) {\n            // 把接收到的消息放到页面中（e.data 就是接收的数据）\n            this.messages.push(e.data)\n        }\n    }\n})\n\n</script>\n~~~\n\n\n\n\n\n\n\n# 案例、聊天室：频道聊天\n\n频道列表页：index.html\n\n~~~html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n    li{\n        padding: 5px;\n        list-style-type: none;\n        border: 1px solid #ccc;\n    }\n    </style>\n</head>\n<body>\n    <div id=\"app\">\n        <h3>房间列表</h3>\n        <ul>\n            <li v-for=\"(v,k) in rooms\">\n                <p><a :href=\"'room.html?id=' + v.id\">{{v.title}}</a></p>\n                <p>主播：{{v.username}}</p>\n            </li>\n        </ul>\n    </div>\n</body>\n</html>\n<script src=\"vue.min.js\"></script>\n<script>\n\nnew Vue({\n    el:'#app',\n    data: {\n        rooms: [\n            {\n                id: 1,\n                title: '世界杯',\n                username: '大灰狼'\n            },\n            {\n                id: 2,\n                title: 'PHP',\n                username: '大雷'\n            }\n        ]\n    }\n})\n\n</script>\n~~~\n\n频道聊天室：room.html\n\n~~~html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <ul>\n            <li v-for=\"(v,k) in messages\">\n                有人说：{{v}}\n            </li>\n        </ul>\n        <textarea v-model=\"content\"></textarea>\n        <input @click=\"submit\" type=\"button\" value=\"发送\">\n    </div>\n</body>\n</html>\n<script src=\"vue.min.js\"></script>\n<script>\n\nnew Vue({\n    el:'#app',\n    data: {\n        ws: null,  // 保存 WebSocket 对象\n        content:'',\n        messages: []  // 保存所有接收的消息\n    },\n    // 当 vue 创建时调用\n    created: function(){\n        let get = GetRequest()\n        // 获取 id\n        this.ws = new WebSocket('ws://127.0.0.1:8686?room_id='+get.id)\n        this.ws.onopen = this.open\n        this.ws.onmessage = this.message\n    },\n    methods:{\n        submit:function(){\n            // 把框里的内容发送到服务器\n            this.ws.send( this.content )\n            // 清空框\n            this.content = ''\n        },\n        open: function() {\n            alert('连接成功！')\n        },\n        message: function(e) {\n            // 把接收到的消息放到页面中（e.data 就是接收的数据）\n            this.messages.push(e.data)\n        }\n    }\n})\n\n// 从百度里找到的一个可以接收所有 URL 上?后的参数的函数\n// 这个函数会解析 url 上的参数并返回一个对象，保存所有的参数\n// 返回数据：{id:1}\nfunction GetRequest() {   \n   var url = location.search; //获取url中\"?\"符后的字串   \n   var theRequest = new Object();   \n   if (url.indexOf(\"?\") != -1) {   \n      var str = url.substr(1);   \n      strs = str.split(\"&\");   \n      for(var i = 0; i < strs.length; i ++) {   \n         theRequest[strs[i].split(\"=\")[0]]=unescape(strs[i].split(\"=\")[1]);   \n      }   \n   }   \n   return theRequest;   \n}   \n\n\n</script>\n~~~\n\n\n\n服务器：server.php\n\n~~~php\n<?php\n\n/*\nWebSocket 的服务器端\n*/\n\nuse Workerman\\Worker;\nrequire_once '../Workerman-master/Autoloader.php';\n// 实例化 Worker 类对象\n$worker = new Worker('websocket://0.0.0.0:8686');\n// 设置进程数\n$worker->count = 1;\n\n/*\n定义一个房间的数组，保存每个房间中的客户端，这样在群发时就不需要循环所有的客户端了，\n只需要循环自己房间这个数组即可（这样做会占用更多的内存，但性能会提高（内存换性能））\n$rooms[\n    1  => [小明，三毛, '四娃']\n    2  => [大娃，二娃，三娃]\n];\n\n$rooms[1][] = '四娃'\n结构：二维数组\n下标：房间的ID\n值：保存房间中所有的客户端\n*/\n$rooms = [];\n\n// 绑定连接的回调函数，这个函数会在有客户端连接时调用\n// 参数：TcpConnection 类的对象，代表每个客户端\n$worker->onConnect = function( $connection ) {\n\n    // 为了能够使用 $_GET 接收连接时的参数，我们需要在这里绑定一个 onWebSocketConnect\n    // 的回调函数，然后在函数中就可以使用 $_GET 接收参数了\n    $connection->onWebSocketConnect = function ($connection, $http_header) {\n        // 保存这个客户端所在的房间号\n        $connection->room_id = $_GET['room_id'];\n\n        global $rooms;\n        // 把这个客户端保存到自己房间的数组中\n        $rooms[$_GET['room_id']][] = $connection;\n    };\n};\n// 接收消息\n$worker->onMessage = function($connection, $data) {\n    global $worker, $rooms;\n    // 只循环发消息这个客户端所在的房间数组中的客户端\n    foreach($rooms[$connection->room_id] as $c)\n    {\n        $c->send($data);\n    }\n};\n// 当有客户端断开连接就从数组中删除\n// 参数 $connection 代表断开连接的客户端\n$worker->onClose = function ($connection) {\n    // 从房间数组中删除这个客户端\n    global $rooms;\n    // 循环这个客户端所在的房间数组，并找到这个客户端在数组中的下标 ，然后删除\n    foreach($rooms[$connection->room_id] as $k => $c)\n    {\n        if($c == $connection)\n            unset($rooms[$connection->room_id][$k]);\n    }\n};\n\n// 运行\nWorker::runAll();\n~~~\n\n\n\n\n\n\n\n\n\n\n\n# 聊天室\n\nGitHub 地址：https://github.com/fortheday001/workerman-chat.git \n\n使用技术：websocket、workerman、vue\n\n效果：输入用户名进入聊天室，进入之后可以开始群聊。\n\n![](http://a.hiphotos.baidu.com/image/%70%69%63/item/902397dda144ad346955820cdda20cf430ad8556.jpg)\n\n\n\n\n\n## 服务器端\n\nserver.php\n\n~~~php\n<?php\nuse Workerman\\Worker;\nrequire_once '../Workerman-master/Autoloader.php';\n// 保存所有用户\n$allUsers=[];\n// 有连接时调用\nfunction connect($connection)\n{\n\t$connection->onWebSocketConnect = function ($connection, $http_header) {\n        global $allUsers;\n        // 保存当前用户到用户列表\n        $allUsers[$connection->id] = ['username'=>$_GET['username']];\n        // 保存当前用户名到当前连接的 $connection 对象上\n        $connection->username = $_GET['username'];\n        // 给所有客户端发消息\n        sendToAll([\n            'username'=>$connection->username,\n            'content'=>'加入了聊天室',\n            'datetime'=>date('Y-m-d H:i'),\n            'allUsers'=>$allUsers,\n        ]);\n    };\n}\n// 当收到数据时调用\nfunction message($connection, $data)\n{\n    // 转发消息给所有客户端\n    sendToAll([\n        'username'=>$connection->username,\n        'content'=>$data,\n        'datetime'=>date('Y-m-d H:i')\n    ]);\n}\n// 当有客户端断开连接时调用\nfunction close($connection)\n{\n    global $allUsers;\n    // 从用户列表数组中删除当前退出的用户\n    unset($allUsers[$connection->id]);\n    // 给所有用户发消息\n    sendToAll([\n        'username'=>$connection->username,\n        'content'=>'离开了聊天室',\n        'datetime'=>date('Y-m-d H:i'),\n        'allUsers'=>$allUsers\n    ]);\n}\n// 给所有人发消息\nfunction sendToAll($data)\n{\n    global $worker;\n    if(is_array($data))\n    {\n        $data = json_encode($data);\n    }\n    // 循环所有客户端\n    foreach($worker->connections as $c)\n    {\n        $c->send($data);\n    }\n}\n\n// 绑定端口\n$worker = new Worker('websocket://0.0.0.0:8686');\n// 设置进程数为1\n$worker->count = 1; \n// 设置回调函数\n$worker->onConnect = 'connect';\n$worker->onMessage = 'message';\n$worker->onClose = 'close';\n// 启动\nWorker::runAll();\n~~~\n\n\n\n## 客户端\n\nroom.html\n\n~~~html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>聊天室</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    <div id=\"app\">\n        <div class=\"container\">\n            <!-- 消息列表 -->\n            <div class=\"message-list box\">\n                <h3>消息列表</h3>\n                <dl v-for=\"(v,k) in messageList\" :key=\"k\">\n                    <dt><strong>{{v.username}}</strong> 在 <time>{{ v.datetime }}</time> 说：</dt>\n                    <dd>{{ v.content }}</dd>\n                </dl>\n            </div>\n            <!-- 用户列表 -->\n            <div class=\"user-list box\">\n                <h3>用户列表 <a @click=\"logout\" href=\"#\">退出</a></h3>\n                <ul>\n                    <li @click=\"userClicked\" v-for=\"(v,k) in userList\">{{ v.username }}</li>\n                </ul>\n            </div>\n        </div>\n        <!-- 发送消息框 -->\n        <div class=\"container send-box\">\n            <textarea v-model=\"message\"></textarea>\n            <input @click=\"send\" id=\"btn-send\" type=\"button\" value=\"发送\">\n        </div>\n        <!-- 登录表单 -->\n        <div :class=\"{'login':true,'hide':layerHide}\">\n            <div><input v-model=\"username\" type=\"text\" placeholder=\"输入用户名\"></div>\n            <div><input @click=\"dologin\" type=\"button\" value=\"登录\"></div>\n        </div>\n        <!-- 登录时黑色背景层 -->\n        <div :class=\"{'layer':true,'hide':layerHide}\"></div>\n    </div>\n    \n    <script src=\"vue.min.js\"></script>\n    <script src=\"room.js\"></script>\n</body>\n</html>\n~~~\n\nstyle.css\n\n~~~css\nhtml,body,div,ul,form,dl,dt,dd {\n    margin: 0;\n    padding: 0;\n}\na {\n    text-decoration: none;\n}\n.container {\n    width: 800px;\n    margin: 0 auto;\n    margin-bottom: 10px;\n    overflow: hidden;\n}\n.hide {\n    display: none;\n}\n.box {\n    border: 1px solid #CCC;\n    height: 500px;\n    padding: 10px;\n    overflow-y: scroll;\n}\n.box h3 {\n    border-bottom: 1px solid #ccc;\n    padding-bottom: 5px;\n}\n.message-list {\n    width: 70%;\n    float: left;\n    \n}\n.message-list dl {\n    margin-bottom: 20px;\n}\n.message-list dt {\n    padding: 5px;\n    background-color: #eee;\n}\n.message-list dd {\n    padding: 10px;\n}\n.message-list time {\n    color: #999;\n}\n.user-list {\n    width: 20%;\n    float: right;\n}\n.user-list li {\n    cursor: pointer;\n    padding: 5px;\n}\n.user-list li:hover {\n    background-color: #eee;\n}\n.send-box {\n    height: 80px;\n}\n.send-box textarea {\n    height: 92%;\n    width: 85%;\n}\n#btn-send {\n    height: 100%;\n    width: 13%;\n    border: 1px solid #ccc;\n    float: right;\n    cursor: pointer;\n    font-size: 20px;\n}\n.layer {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    left: 0;\n    top: 0;\n    background-color: #000;\n    z-index: 8888;\n    opacity: .5;\n}\n.login {\n    position: absolute;\n    width: 200px;\n    height: 100px;\n    background-color: #fff;\n    padding: 20px;\n    border: 1px solid #999;\n    left: 150px;\n    top: 100px;\n    z-index: 9999;\n}\n~~~\n\n\n\nroom.js\n\n~~~js\nnew Vue({\n    el: \"#app\",\n    data: {\n        messageList: [],      // 消息列表\n        userList: [],       // 在线用户列表  \n        message: '',       // 消息框中的内容\n        ws: null,           // websocket 对象\n        layerHide: false,   // 是否隐藏登录框\n        host: '127.0.0.1:8686',    // 服务器地址\n        username: localStorage.getItem('username')    // 当前用户名\n    },\n    methods: {\n        // 退出按钮\n        logout: function() {\n            localStorage.removeItem('username')\n            this.username = undefined\n            this.layerHide = false\n            this.ws.close()\n        },\n        // 登录按钮\n        dologin: function() {\n            if(this.username != '')\n            {\n                localStorage.setItem('username', this.username)\n                this.layerHide = true\n                this.ws_conn()\n            }\n        },\n        // 发消息按钮\n        send: function() {\n            if(this.message == '')\n                return \n            this.ws.send(this.message)\n            this.message = ''\n        },\n        // 聊天列表滚动到底部\n        scrollToBottom: function() {\n            let d = document.querySelector('.message-list')\n            d.scrollTop = d.scrollHeight\n        },\n        // 收到消息时调用\n        ws_message: function(e){\n            let data = JSON.parse(e.data)\n            this.messageList.push(data)\n\n            setTimeout(()=>{\n                this.scrollToBottom()\n            }, 100)\n\n            if(data.allUsers)\n            {\n                this.userList = data.allUsers\n            }\n        },\n        // 连接服务器\n        ws_conn: function() {\n            this.ws = new WebSocket('ws://'+this.host+'?username='+this.username)\n            this.ws.onopen = this.ws_open\n            this.ws.onmessage = this.ws_message\n            this.ws.onclose = this.ws_close\n        }\n    },\n    // 页面初始化\n    created: function(){\n        if(localStorage.getItem('username'))\n        {\n            this.layerHide = true\n            this.ws_conn()\n        }\n    }\n})\n~~~\n\n\n\n\n\n\n\n# 坦克大战\n\nGitHub 地址：https://github.com/fortheday001/workerman-tankwar.git\n\n## 服务器端\n\nserver.php\n\n~~~php\n<?php\nuse Workerman\\Worker;\nrequire_once '../Workerman-master/Autoloader.php';\n// 保存所有坦克\n$tanks=[];\n// 有连接时调用\nfunction connect($connection)\n{\n    $connection->onWebSocketConnect = function ($connection, $http_header) {\n        global $tanks;\n        // 把服务器上保存的所有坦克的信息发送给该客户端\n        $connection->send(json_encode([\n            'type'=>'all',\n            'tanks'=>$tanks\n        ]));\n        // 在服务器上保存当前坦克的信息\n        $tanks[$connection->id] = [$_GET['left'],$_GET['top']];\n        // 给所有其它客户端发送添加当前坦克的消息\n        sendToAll([\n            'type'=>'add',\n            'id'=>$connection->id,\n            'left'=>$_GET['left'],\n            'top'=>$_GET['top']\n        ], $connection->id);\n    };\n}\n// 当收到移动数据时调用\nfunction message($connection, $data)\n{\n    global $tanks;\n    // 更新服务器上保存的当前坦克的位置信息\n    $tanks[$connection->id] = explode(',', $data);\n    // 把坦克移动之后的位置发送给所有其它客户端\n    sendToAll([\n        'type'=>'move',\n        'id'=>$connection->id,\n        'left'=>$tanks[$connection->id][0],\n        'top'=>$tanks[$connection->id][1],\n        'transform'=>$tanks[$connection->id][2],\n    ]);\n}\n// 当有客户端断开连接时调用\nfunction close($connection)\n{\n    global $tanks;\n    // 从服务器中删除当前客户端的信息\n    unset($tanks[$connection->id]);\n    // 通知所有客户端删除该坦克\n    sendToAll([\n        'type'=>'remove',\n        'id'=>$connection->id,\n    ]);\n}\n// 功能函数：给所有客户端发消息，可以通过第二个参数排除某个客户端\nfunction sendToAll($data, $except='')\n{\n    global $worker;\n    // 如果是数组就转成 JSON 字符串\n    if(is_array($data))\n        $data = json_encode($data);\n    // 循环所有客户端\n    foreach($worker->connections as $c)\n    {\n        // 跳过要排除的客户端（不给这个客户端发消息）\n        if($except && $except==$c->id)\n            continue;\n        // 发消息\n        $c->send($data);\n    }\n}\n// 绑定端口\n$worker = new Worker('websocket://0.0.0.0:8686');\n// 设置进程数为1\n$worker->count = 1; \n// 设置回调函数\n$worker->onConnect = 'connect';\n$worker->onMessage = 'message';\n$worker->onClose = 'close';\n// 启动\nWorker::runAll();\n~~~\n\n\n\n## 客户端\n\ntank.html\n\n~~~js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>坦克大战</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    \n    <script src=\"tank.js\"></script>\n</body>\n</html>\n~~~\n\nstyle.css\n\n~~~css\nhtml,body,div,ul,form,dl,dt,dd {\n    margin: 0;\n    padding: 0;\n}\na {\n    text-decoration: none;\n}\n.tank {\n    position: absolute;\n    width: 40px;\n    height: 30px;\n    background-color: yellow;\n    top: 0;\n    left: 0;\n    border: 1px solid #000;\n}\n.tank:before {\n    position: absolute;\n    left: 50%;\n    top: 45%;\n    content: \"\";\n    display: block;\n    width: 100%;\n    height: 10%;\n    background-color: #f00;\n}\n.tank:after {\n    position: absolute;\n    left: 40%;\n    top: 35%;\n    content: \"\";\n    display: block;\n    width: 30%;\n    height: 30%;\n    border-radius: 50%;\n    background-color: #f00;\n}\n~~~\n\ntank.js\n\n~~~js\nvar my = null       // 我的坦克\nvar allTanks = []   // 所有坦克\nvar ws = null        // WebSocket 对象\nconst host = '127.0.0.1:8686'      // 服务器地址\nconst myColor = '#4baf32'     // 我的坦克颜色\nconst speed = 8         // 移动速度\nconst maxWidth = 1100      // 随机生成坦克位置时最大 left\nconst maxHeight = 800      // 随机生成坦克位置时最大 top\n\n// 随机生成我的坦克所在的位置\nmyPos = {\n    left: randomBetween(0, maxWidth),\n    top: randomBetween(0, maxHeight)\n}\n// 绑定 上、下、左、右 四个键盘子的点击事件\nwindow.onkeydown = function(e) {\n    switch(e.keyCode)\n    {\n        case 38:\n            move('up')\n            break\n        case 40:\n            move('down')\n            break\n        case 37:\n            move('left')\n            break\n        case 39:\n            move('right')\n            break\n    }\n}\n// 移动我的坦克\nfunction move(direction) {\n    if(direction == 'up')\n    {\n        // 旋转\n        my.style.transform = 'rotate(-90deg)'\n        // 移动\n        myPos.top -= speed\n        my.style.top = myPos.top + 'px'\n    }\n    else if(direction == 'down')\n    {\n        my.style.transform = 'rotate(90deg)'\n        myPos.top += speed\n        my.style.top = myPos.top + 'px'\n    }\n    else if(direction == 'left')\n    {\n        my.style.transform = 'rotate(180deg)'\n        myPos.left -= speed\n        my.style.left = myPos.left + 'px'\n    }\n    else if(direction == 'right')\n    {\n        my.style.transform = 'rotate(0deg)'\n        myPos.left += speed\n        my.style.left = myPos.left + 'px'\n    }\n    ws.send(myPos.left+','+myPos.top+','+my.style.transform)\n}\n// 向页面中添加一个坦克\nfunction addTank(left,top,transform) {\n    transform = transform || 'rotate(0deg)'\n    let tank = document.createElement('div')\n    tank.className = 'tank'\n    tank.style.left = left + 'px'\n    tank.style.top = top + 'px'\n    tank.style.transform = transform\n    document.body.append(tank)\n    allTanks.push(tank)\n    return tank\n}\n// 生成一个随机数\nfunction randomBetween(Min,Max){\n    var Range = Max - Min;\n    var Rand = Math.random();\n    var num = Min + Math.round(Rand * Range); //四舍五入\n    return num;\n}\n// 生成我的坦克\nmy = addTank(myPos.left, myPos.top)\nmy.style.backgroundColor = myColor\n// 连接服务器\nws = new WebSocket('ws://'+host+'?left='+myPos.left+'&top='+myPos.top)\n// 接收并处理服务器的消息\nws.onmessage = function(e) {\n    let data = JSON.parse(e.data)\n    switch(data.type)\n    {\n        // 当消息类型为添加时，就向页面添加一个新坦克\n        case 'add':\n            allTanks[data.id] = addTank(data.left, data.top)\n            break\n        // 当消息类型为移动时，就移动坦克（通过 id 区分坦克）\n        case 'move':\n            if(allTanks[data.id]!=undefined)\n            {\n                allTanks[data.id].style.left = data.left + 'px'\n                allTanks[data.id].style.top = data.top + 'px'\n                allTanks[data.id].style.transform = data.transform\n            }\n            break\n        // 当收到删除的消息时，就删除这个坦克（通过 id 区分坦克）\n        case 'remove':\n            if(allTanks[data.id]!=undefined)\n            {\n                document.body.removeChild(allTanks[data.id])\n                allTanks.splice(data.id,1)\n            }\n            break\n        // 当收到所有坦克的消息时，就在页面中添加所有的坦克\n        case 'all':\n            for(let i in data.tanks)\n            {\n                allTanks[i] = addTank(data.tanks[i][0], data.tanks[i][1], data.tanks[2])\n            }\n            break\n    }\n}\n~~~\n\n","tags":["PHP"]},{"title":"Git强制覆盖本地代码","url":"/2018/06/17/Git强制覆盖本地文件/","content":"\n\n### 1. 将远程库下载到本地\n``` bash\ngit fetch --all\n```\n\n### 2. 清空暂存区，回退到最新版本\n``` bash\ngit reset --hard origin/master\n```\n\n### 3. 拉取最新代码\n``` bash\ngit pull\n```\n","tags":["Git"]}]